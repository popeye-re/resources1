2)
head = input("Enter character 
that represents the starting 
delimiter: ") 
tail = input(" Enter character 
that represents the ending 
delimiter: ")  
st = input("Enter the characters 
to be stuffed: ") 
res=head  
for i in st: 
if i==head or i ==tail: 
res = res + i + i 
else: 
res = res + i  
 res = res+tail 
print("Frame after character 
stuffing: ", res)
OUTPUT: 
Enter character that represents 
the starting delimiter: d  
Enter character that represents 
the ending delimiter: g 
Enter the characters to be 
stuffed: goodday 
Frame after character stuffing: 
dggooddddayg 

st = input ("Enter the frame: ") 
count = 0 
res = "" 
for i in st: 
if i == '1' and count < 5:  
res += '1' 
count += 1 
elif i == ' ':  
pass 
else: 
res += i count = 0 
if count == 5:  
res += '0' 
count= 0 
print ("Frame after bit 
stuffing: ", res) 
 
OUTPUT: 
Enter the frame: 01111110 
Frame after bit stuffing: 
011111010 


3)
s1 = input("Enter the string of 0's and 1's as subunit1: ")  
s2 = input("Enter the string of 0's and 1's as subunit2: ")  
s1 = s1[::-1] 
s2 = s2[::-1] 
 
res = "" 
c = '0' 
 
for i,j in zip(s1, s2): 
if i == '0' and j == '0' and c == '0':  
res += '0' 
c = '0' 
elif i == '0' and j == '0' and c == '1':  
res += '1' 
c = '0' 
elif i == '0' and j == '1' and c == '0':  
res += '1' 
c = '0' 
elif i == '0' and j == '1' and c == '1':  
res += '0' 
c = '1' 
elif i == '1' and j == '0' and c == '0':  
res += '1' 
c = '0' 
elif i == '1' and j == '0' and c == '1':  
res += '0' 
c = '1' 
elif i == '1' and j == '1' and c == '0':  
res += '0' 
c = '1' 
elif i == '1' and j == '1' and c == '1':  
res += '1' 
c = '1' 
 
 
if c == '1': 
ans = "" 
for i in res: 
if i == '1' and c == '1':  
ans += '0' 
c = '1' 
elif i == '0' and c == '0': 
ans += '0' 
c = '0' 
else : 
ans += '1' 
c = '0' 
res = ans 
 
final = ""  
for i in res: 
if i == '1': 
final += '0'  
else: 
final += '1' 
print("Checksum of two subunits: ", final[::-1].strip())
OUTPUT: 
Enter the string of 0's and 1's as subunit1: 10101001  
Enter the string of 0's and 1's as subunit2: 00111001  
Checksum of two subunits: 00011101 

5)
def xor(a, b): 
result = '' 
for i in range(1, len(b)): 
result += '0' if a[i] == b[i] else '1' 
return result 
def divide(dividend, divisor): 
pick = len(divisor) 
tmp = dividend[0:pick] 
while pick < len(dividend): 
if tmp[0] == '1':
    tmp = xor(divisor, tmp) + dividend[pick] 
        else: 
            tmp = xor('0' * pick, tmp) + dividend[pick] 
        pick += 1 
 
    if tmp[0] == '1': 
        tmp = xor(divisor, tmp) 
    else: 
        tmp = xor('0' * len(divisor), tmp) 
 
    return tmp 
 
# -------- User Input Section -------- 
key = str(input("Enter the CRC polynomial (as a binary string, e.g., 1101): ")).strip() 
if not key or set(key) - {'0', '1'}: 
    raise ValueError("Polynomial must be a binary string with only 0s and 1s.") 
 
send = str(input("Enter the binary data to be sent: ")).strip() 
if not send or set(send) - {'0', '1'}: 
    raise ValueError("Send data must be a binary string with only 0s and 1s.") 
 
rec = str(input("Enter the binary data received: ")).strip() 
if not rec or set(rec) - {'0', '1'}: 
    raise ValueError("Received data must be a binary string with only 0s and 1s.") 
 
# -------- CRC Encoding -------- 
l_key = len(key) 
send_extended = send + '0' * (l_key - 1)
    tmp = xor(divisor, tmp) + dividend[pick] 
        else: 
            tmp = xor('0' * pick, tmp) + dividend[pick] 
        pick += 1 
 
    if tmp[0] == '1': 
        tmp = xor(divisor, tmp) 
    else: 
        tmp = xor('0' * len(divisor), tmp) 
 
    return tmp 
 
# -------- User Input Section -------- 
key = str(input("Enter the CRC polynomial (as a binary string, e.g., 1101): ")).strip() 
if not key or set(key) - {'0', '1'}: 
    raise ValueError("Polynomial must be a binary string with only 0s and 1s.") 
 
send = str(input("Enter the binary data to be sent: ")).strip() 
if not send or set(send) - {'0', '1'}: 
    raise ValueError("Send data must be a binary string with only 0s and 1s.") 
 
rec = str(input("Enter the binary data received: ")).strip() 
if not rec or set(rec) - {'0', '1'}: 
    raise ValueError("Received data must be a binary string with only 0s and 1s.") 
 
# -------- CRC Encoding -------- 
l_key = len(key) 
send_extended = send + '0' * (l_key - 1)
remainder = divide(send_extended, key) 
encoded_data = send + remainder 
print("\nEncoded data sent:", encoded_data) 
# -------- CRC Decoding -------- 
remainder_received = divide(rec, key) 
if remainder_received == '0' * (l_key - 1): 
print("No error detected in received data.") 
else: 
print("Error detected in received data.")

8)
 #Server Program 
import socket 
import time 
import random 
s = socket.socket()
 s.bind(("localhost", 8020)) 
s.listen(5)
 c, adr = s.accept()
 print("Waiting for connection...")
 print("connection to " + str(adr) + " established") 
a = int(input("enter total number of frames: "))
 x = 0
 print("sending -->", x)
 c.send(str(x).encode()) 
while a > 1:
    timer = 5 
    t = random.randint(1, 7) 
    msg = c.recv(1).decode() 
    if timer > t:
        time.sleep(3) 
        print("ack-->", msg) 
        x = int(msg)
        print("sending -->", str(x))
        c.send(str(x).encode()) 
    else:
        time.sleep(3) 
        print("timeout") 
        print("sending again-->", x) 
        c.send(str(x).encode()) 
        a = a + 1  # Resend counts as not successful, so
 increment back
    a = a - 1  # Decrease the number of remaining frames
 # Close connection
 c.close()
 s.close()
 #receiver Program 
import socket
 s = socket.socket()
 s.connect(("localhost", 8020))
 while True:
    msg = s.recv(1).decode()
    print("Received --> ", msg)
    x = int(msg)
    
    if x == 0:
        x = x + 1
        s.send(str(x).encode())
    else:
        x = x - 1
        s.send(str(x).encode())
 s.close()
