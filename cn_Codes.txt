2)
head = input("Enter character 
that represents the starting 
delimiter: ") 
tail = input(" Enter character 
that represents the ending 
delimiter: ")  
st = input("Enter the characters 
to be stuffed: ") 
res=head  
for i in st: 
if i==head or i ==tail: 
res = res + i + i 
else: 
res = res + i  
 res = res+tail 
print("Frame after character 
stuffing: ", res)
OUTPUT: 
Enter character that represents 
the starting delimiter: d  
Enter character that represents 
the ending delimiter: g 
Enter the characters to be 
stuffed: goodday 
Frame after character stuffing: 
dggooddddayg 

st = input ("Enter the frame: ") 
count = 0 
res = "" 
for i in st: 
if i == '1' and count < 5:  
res += '1' 
count += 1 
elif i == ' ':  
pass 
else: 
res += i count = 0 
if count == 5:  
res += '0' 
count= 0 
print ("Frame after bit 
stuffing: ", res) 
 
OUTPUT: 
Enter the frame: 01111110 
Frame after bit stuffing: 
011111010 


3)
s1 = input("Enter the string of 0's and 1's as subunit1: ")  
s2 = input("Enter the string of 0's and 1's as subunit2: ")  
s1 = s1[::-1] 
s2 = s2[::-1] 
 
res = "" 
c = '0' 
 
for i,j in zip(s1, s2): 
if i == '0' and j == '0' and c == '0':  
res += '0' 
c = '0' 
elif i == '0' and j == '0' and c == '1':  
res += '1' 
c = '0' 
elif i == '0' and j == '1' and c == '0':  
res += '1' 
c = '0' 
elif i == '0' and j == '1' and c == '1':  
res += '0' 
c = '1' 
elif i == '1' and j == '0' and c == '0':  
res += '1' 
c = '0' 
elif i == '1' and j == '0' and c == '1':  
res += '0' 
c = '1' 
elif i == '1' and j == '1' and c == '0':  
res += '0' 
c = '1' 
elif i == '1' and j == '1' and c == '1':  
res += '1' 
c = '1' 
 
 
if c == '1': 
ans = "" 
for i in res: 
if i == '1' and c == '1':  
ans += '0' 
c = '1' 
elif i == '0' and c == '0': 
ans += '0' 
c = '0' 
else : 
ans += '1' 
c = '0' 
res = ans 
 
final = ""  
for i in res: 
if i == '1': 
final += '0'  
else: 
final += '1' 
print("Checksum of two subunits: ", final[::-1].strip())
OUTPUT: 
Enter the string of 0's and 1's as subunit1: 10101001  
Enter the string of 0's and 1's as subunit2: 00111001  
Checksum of two subunits: 00011101 

5)
def xor(a, b): 
result = '' 
for i in range(1, len(b)): 
result += '0' if a[i] == b[i] else '1' 
return result 
def divide(dividend, divisor): 
pick = len(divisor) 
tmp = dividend[0:pick] 
while pick < len(dividend): 
if tmp[0] == '1':
    tmp = xor(divisor, tmp) + dividend[pick] 
        else: 
            tmp = xor('0' * pick, tmp) + dividend[pick] 
        pick += 1 
 
    if tmp[0] == '1': 
        tmp = xor(divisor, tmp) 
    else: 
        tmp = xor('0' * len(divisor), tmp) 
 
    return tmp 
 
# -------- User Input Section -------- 
key = str(input("Enter the CRC polynomial (as a binary string, e.g., 1101): ")).strip() 
if not key or set(key) - {'0', '1'}: 
    raise ValueError("Polynomial must be a binary string with only 0s and 1s.") 
 
send = str(input("Enter the binary data to be sent: ")).strip() 
if not send or set(send) - {'0', '1'}: 
    raise ValueError("Send data must be a binary string with only 0s and 1s.") 
 
rec = str(input("Enter the binary data received: ")).strip() 
if not rec or set(rec) - {'0', '1'}: 
    raise ValueError("Received data must be a binary string with only 0s and 1s.") 
 
# -------- CRC Encoding -------- 
l_key = len(key) 
send_extended = send + '0' * (l_key - 1)
    tmp = xor(divisor, tmp) + dividend[pick] 
        else: 
            tmp = xor('0' * pick, tmp) + dividend[pick] 
        pick += 1 
 
    if tmp[0] == '1': 
        tmp = xor(divisor, tmp) 
    else: 
        tmp = xor('0' * len(divisor), tmp) 
 
    return tmp 
 
# -------- User Input Section -------- 
key = str(input("Enter the CRC polynomial (as a binary string, e.g., 1101): ")).strip() 
if not key or set(key) - {'0', '1'}: 
    raise ValueError("Polynomial must be a binary string with only 0s and 1s.") 
 
send = str(input("Enter the binary data to be sent: ")).strip() 
if not send or set(send) - {'0', '1'}: 
    raise ValueError("Send data must be a binary string with only 0s and 1s.") 
 
rec = str(input("Enter the binary data received: ")).strip() 
if not rec or set(rec) - {'0', '1'}: 
    raise ValueError("Received data must be a binary string with only 0s and 1s.") 
 
# -------- CRC Encoding -------- 
l_key = len(key) 
send_extended = send + '0' * (l_key - 1)
remainder = divide(send_extended, key) 
encoded_data = send + remainder 
print("\nEncoded data sent:", encoded_data) 
# -------- CRC Decoding -------- 
remainder_received = divide(rec, key) 
if remainder_received == '0' * (l_key - 1): 
print("No error detected in received data.") 
else: 
print("Error detected in received data.")

8)
.Program to implement Sliding window protocol for 
Selective repeat.
 #sender
 import socket
 import random
 import time
 # Create a socket object
 s = socket.socket()
 s.bind(("localhost", 8038))
 s.listen(5)
 print("Waiting for connection...")
 c, adr = s.accept()
 print("From address", str(adr), "connection has been 
established")
 # Take inputs
 n = int(input("Enter number of frames: "))
 N = int(input("Enter window size: "))
 seq = 1  # Keeps track of the window starting point
 frame = 1  # Frame number to be sent
 # Send first N frames
 for i in range(N):
 print('Frame sent ->', frame)
 c.send(str(frame).encode())
 frame += 1
 time.sleep(2)
 # Simulate sending remaining frames
 while frame <= n:
 t = random.randint(1, 7)  # Simulate ACK timing
    msg = c.recv(1024).decode()  # Receive ACK
    if not msg:
        break  # Client might have closed connection
    msg = int(msg)
    print("Frame", msg, "acknowledged.")
    timer = 5  # Reset timer
    if timer > t:
        # Acknowledgement received
        print("Acknowledgement received")
        print('Frame sent ->', frame)
        c.send(str(frame).encode())
        seq += 1
        frame += 1
        time.sleep(2)
    else:
        # Acknowledgement lost or not received
        print("Acknowledgement not received")
        print('Retransmitting from frame ->', msg)
        frame = msg  # Reset frame to resend
        for i in range(N):
            if frame > n:
                break
            print('Frame resent ->', frame)
            c.send(str(frame).encode())
            frame += 1
            time.sleep(2)
 c.close()
 s.close()
# Receiver
 import socket
 import time
 s = socket.socket()
 s.connect(("localhost", 8038))
 while True:
 msg = s.recv(2).decode()
 if not msg:
 break  # Exit the loop if the server closes the 
connection
 print("Received -->", int(msg))
 s.send(str(msg).encode())  # Send ACK
 time.sleep(1)
 s.close()