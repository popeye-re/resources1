2)a)character
head = input("Enter character that represents the starting delimiter: ")
tail = input("Enter character that represents the ending delimiter: ")
st = input("Enter the characters to be stuffed: ")

res = head
for i in st:
    if i == head or i == tail:
        res = res + i + i
    else:
        res = res + i

res = res + tail
print("Frame after character stuffing: ", res)

OUTPUT: 
Enter character that represents the starting delimiter: d  
Enter character that represents the ending delimiter: g 
Enter the characters to be stuffed: goodday 
Frame after character stuffing: dggooddddayg 

b)bit
st = input("Enter the frame: ")
count = 0
res = ""

for i in st:
    if i == '1' and count < 5:
        res += '1'
        count += 1
    elif i == ' ':
        pass
    else:
        res += i
        count = 0

    if count == 5:
        res += '0'
        count = 0

print("Frame after bit stuffing: ", res)

 
OUTPUT: 
Enter the frame: 01111110 
Frame after bit stuffing: 011111010 


3)
s1 = input("Enter the string of 0's and 1's as subunit1: ")
s2 = input("Enter the string of 0's and 1's as subunit2: ")

s1 = s1[::-1]
s2 = s2[::-1]

res = ""
c = '0'

for i, j in zip(s1, s2):
    if i == '0' and j == '0' and c == '0':
        res += '0'
        c = '0'
    elif i == '0' and j == '0' and c == '1':
        res += '1'
        c = '0'
    elif i == '0' and j == '1' and c == '0':
        res += '1'
        c = '0'
    elif i == '0' and j == '1' and c == '1':
        res += '0'
        c = '1'
    elif i == '1' and j == '0' and c == '0':
        res += '1'
        c = '0'
    elif i == '1' and j == '0' and c == '1':
        res += '0'
        c = '1'
    elif i == '1' and j == '1' and c == '0':
        res += '0'
        c = '1'
    elif i == '1' and j == '1' and c == '1':
        res += '1'
        c = '1'

# Carry Handling
if c == '1':
    ans = ""
    c = '1'
    for i in res:
        if i == '1' and c == '1':
            ans += '0'
            c = '1'
        elif i == '0' and c == '0':
            ans += '0'
            c = '0'
        else:
            ans += '1'
            c = '0'
    res = ans

# Final complement
final = ""
for i in res:
    if i == '1':
        final += '0'
    else:
        final += '1'

print("Checksum of two subunits: ", final[::-1].strip())

OUTPUT: 
Enter the string of 0's and 1's as subunit1: 10101001  
Enter the string of 0's and 1's as subunit2: 00111001  
Checksum of two subunits: 00011101 

5)
def xor(a, b): 
result = '' 
for i in range(1, len(b)): 
result += '0' if a[i] == b[i] else '1' 
return result 
def divide(dividend, divisor): 
pick = len(divisor) 
tmp = dividend[0:pick] 
while pick < len(dividend): 
if tmp[0] == '1':
    tmp = xor(divisor, tmp) + dividend[pick] 
        else: 
            tmp = xor('0' * pick, tmp) + dividend[pick] 
        pick += 1 
 
    if tmp[0] == '1': 
        tmp = xor(divisor, tmp) 
    else: 
        tmp = xor('0' * len(divisor), tmp) 
 
    return tmp 
 
# -------- User Input Section -------- 
key = str(input("Enter the CRC polynomial (as a binary string, e.g., 1101): ")).strip() 
if not key or set(key) - {'0', '1'}: 
    raise ValueError("Polynomial must be a binary string with only 0s and 1s.") 
 
send = str(input("Enter the binary data to be sent: ")).strip() 
if not send or set(send) - {'0', '1'}: 
    raise ValueError("Send data must be a binary string with only 0s and 1s.") 
 
rec = str(input("Enter the binary data received: ")).strip() 
if not rec or set(rec) - {'0', '1'}: 
    raise ValueError("Received data must be a binary string with only 0s and 1s.") 
 
# -------- CRC Encoding -------- 
l_key = len(key) 
send_extended = send + '0' * (l_key - 1)
    tmp = xor(divisor, tmp) + dividend[pick] 
        else: 
            tmp = xor('0' * pick, tmp) + dividend[pick] 
        pick += 1 
 
    if tmp[0] == '1': 
        tmp = xor(divisor, tmp) 
    else: 
        tmp = xor('0' * len(divisor), tmp) 
 
    return tmp 
 
# -------- User Input Section -------- 
key = str(input("Enter the CRC polynomial (as a binary string, e.g., 1101): ")).strip() 
if not key or set(key) - {'0', '1'}: 
    raise ValueError("Polynomial must be a binary string with only 0s and 1s.") 
 
send = str(input("Enter the binary data to be sent: ")).strip() 
if not send or set(send) - {'0', '1'}: 
    raise ValueError("Send data must be a binary string with only 0s and 1s.") 
 
rec = str(input("Enter the binary data received: ")).strip() 
if not rec or set(rec) - {'0', '1'}: 
    raise ValueError("Received data must be a binary string with only 0s and 1s.") 
 
# -------- CRC Encoding -------- 
l_key = len(key) 
send_extended = send + '0' * (l_key - 1)
remainder = divide(send_extended, key) 
encoded_data = send + remainder 
print("\nEncoded data sent:", encoded_data) 
# -------- CRC Decoding -------- 
remainder_received = divide(rec, key) 
if remainder_received == '0' * (l_key - 1): 
print("No error detected in received data.") 
else: 
print("Error detected in received data.")

8)
# Server Program
import socket
import time
import random



s = socket.socket()
s.bind(("localhost", 8020))
s.listen(5)

print("Waiting for connection...")
c, adr = s.accept()
print("connection to " + str(adr) + " established")

a = int(input("enter total number of frames: "))
x = 0
print("sending -->", x)
c.send(str(x).encode())

while a > 1:
    timer = 5
    t = random.randint(1, 7)
    msg = c.recv(1).decode()
    if not msg:
     
        break
    if timer > t:
        time.sleep(3)
        print("ack-->", msg)
        x = int(msg)
        print("sending -->", str(x))
        c.send(str(x).encode())
    else:
        time.sleep(3)
        print("timeout")
        print("sending again-->", x)
        c.send(str(x).encode())
        a = a + 1  
    a = a - 1 

try:
    c.close()
except:
    pass
s.close()


# Receiver Program
import socket

s = socket.socket()
s.connect(("localhost", 8020))

while True:
    try:
        data = s.recv(1)
    except ConnectionResetError:
    
        break

    if not data:
       
        break

    msg = data.decode()
    print("Received --> ", msg)
    x = int(msg)

    if x == 0:
        x = x + 1
        s.send(str(x).encode())
    else:
        x = x - 1
        s.send(str(x).encode())

s.close()


Waiting for connection...
connection to ('127.0.0.1', 55078) established
enter total number of frames:  6
sending --> 0
ack--> 1
sending --> 1
timeout
sending again--> 1
timeout
sending again--> 1
ack--> 0
sending --> 0
ack--> 1
sending --> 1
ack--> 0
sending --> 0
timeout
sending again--> 0
ack--> 1
sending --> 1

Received -->  0
Received -->  1
Received -->  1
Received -->  1
Received -->  0
Received -->  1
Received -->  0
Received -->  0
Received -->  1
